
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pcapkit.reassembly.tcp &#8212; PyPCAPKit 0.15.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pcapkit.reassembly.tcp</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;TCP datagram reassembly</span>

<span class="sd">:mod:`pcapkit.reassembly.tcp` contains</span>
<span class="sd">:class:`~pcapkit.reassembly.reassembly.Reassembly` only,</span>
<span class="sd">which reconstructs fragmented TCP packets back to origin.</span>
<span class="sd">The algorithm for TCP reassembly is described as below.</span>

<span class="sd">Notations::</span>

<span class="sd">    DSN     - Data Sequence Number</span>
<span class="sd">    ACK     - TCP Acknowledgement</span>
<span class="sd">    SYN     - TCP Synchronisation Flag</span>
<span class="sd">    FIN     - TCP Finish Flag</span>
<span class="sd">    RST     - TCP Reset Connection Flag</span>
<span class="sd">    BUFID   - Buffer Identifier</span>
<span class="sd">    HDL     - Hole Discriptor List</span>
<span class="sd">    ISN     - Initial Sequence Number</span>
<span class="sd">    src     - source IP</span>
<span class="sd">    dst     - destination IP</span>
<span class="sd">    srcport - source TCP port</span>
<span class="sd">    dstport - destination TCP port</span>

<span class="sd">Algorithm::</span>

<span class="sd">    DO {</span>
<span class="sd">        BUFID &lt;- src|dst|srcport|dstport|ACK;</span>
<span class="sd">        IF (SYN is true) {</span>
<span class="sd">            IF (buffer with BUFID is allocated) {</span>
<span class="sd">                flush all reassembly for this BUFID;</span>
<span class="sd">                submit datagram to next step;</span>
<span class="sd">            }</span>
<span class="sd">        }</span>

<span class="sd">        IF (no buffer with BUFID is allocated) {</span>
<span class="sd">            allocate reassembly resources with BUFID;</span>
<span class="sd">            ISN &lt;- DSN;</span>
<span class="sd">            put data from fragment into data buffer with BUFID</span>
<span class="sd">                [from octet fragment.first to octet fragment.last];</span>
<span class="sd">            update HDL;</span>
<span class="sd">        }</span>

<span class="sd">        IF (FIN is true or RST is true) {</span>
<span class="sd">            submit datagram to next step;</span>
<span class="sd">            free all reassembly resources for this BUFID;</span>
<span class="sd">            BREAK.</span>
<span class="sd">        }</span>
<span class="sd">    } give up until (next fragment);</span>

<span class="sd">    update HDL: {</span>
<span class="sd">        DO {</span>
<span class="sd">            select the next hole descriptor from HDL;</span>

<span class="sd">            IF (fragment.first &gt;= hole.first) CONTINUE.</span>
<span class="sd">            IF (fragment.last &lt;= hole.first) CONTINUE.</span>

<span class="sd">            delete the current entry from HDL;</span>

<span class="sd">            IF (fragment.first &gt;= hole.first) {</span>
<span class="sd">                create new entry &quot;new_hole&quot; in HDL;</span>
<span class="sd">                new_hole.first &lt;- hole.first;</span>
<span class="sd">                new_hole.last &lt;- fragment.first - 1;</span>
<span class="sd">                BREAK.</span>
<span class="sd">            }</span>

<span class="sd">            IF (fragment.last &lt;= hole.last) {</span>
<span class="sd">                create new entry &quot;new_hole&quot; in HDL;</span>
<span class="sd">                new_hole.first &lt;- fragment.last + 1;</span>
<span class="sd">                new_hole.last &lt;- hole.last;</span>
<span class="sd">                BREAK.</span>
<span class="sd">            }</span>
<span class="sd">        } give up until (no entry from HDL)</span>
<span class="sd">    }</span>

<span class="sd">The following algorithm implement is based on **IP Datagram</span>
<span class="sd">Reassembly Algorithm** introduced in :rfc:`815`. It described an</span>
<span class="sd">algorithm dealing with ``RCVBT`` (fragment received bit table)</span>
<span class="sd">appeared in :rfc:`791`. And here is the process:</span>

<span class="sd">1. Select the next hole descriptor from the hole descriptor</span>
<span class="sd">   list. If there are no more entries, go to step eight.</span>
<span class="sd">2. If ``fragment.first`` is greater than ``hole.last``, go to step one.</span>
<span class="sd">3. If ``fragment.last`` is less than ``hole.first``, go to step one.</span>
<span class="sd">4. Delete the current entry from the hole descriptor list.</span>
<span class="sd">5. If ``fragment.first`` is greater than ``hole.first``, then create a</span>
<span class="sd">   new hole descriptor ``new_hole`` with ``new_hole.first`` equal to</span>
<span class="sd">   ``hole.first``, and ``new_hole.last`` equal to ``fragment.first``</span>
<span class="sd">   minus one (``-1``).</span>
<span class="sd">6. If ``fragment.last`` is less than ``hole.last`` and</span>
<span class="sd">   ``fragment.more_fragments`` is ``true``, then create a new hole</span>
<span class="sd">   descriptor ``new_hole``, with ``new_hole.first`` equal to</span>
<span class="sd">   ``fragment.last`` plus one (``+1``) and ``new_hole.last`` equal to</span>
<span class="sd">   ``hole.last``.</span>
<span class="sd">7. Go to step one.</span>
<span class="sd">8. If the hole descriptor list is now empty, the datagram is now</span>
<span class="sd">   complete. Pass it on to the higher level protocol processor</span>
<span class="sd">   for further handling. Otherwise, return.</span>

<span class="sd">Glossary</span>
<span class="sd">--------</span>

<span class="sd">tcp.packet</span>
<span class="sd">    Data structure for **TCP datagram reassembly**</span>
<span class="sd">    (:meth:`~pcapkit.reassembly.reassembly.Reassembly.reassembly`) is as following:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       packet_dict = Info(</span>
<span class="sd">         bufid = tuple(</span>
<span class="sd">             ip.src,                     # source IP address</span>
<span class="sd">             ip.dst,                     # destination IP address</span>
<span class="sd">             tcp.srcport,                # source port</span>
<span class="sd">             tcp.dstport,                # destination port</span>
<span class="sd">         ),</span>
<span class="sd">         num = frame.number,             # original packet range number</span>
<span class="sd">         syn = tcp.flags.syn,            # synchronise flag</span>
<span class="sd">         fin = tcp.flags.fin,            # finish flag</span>
<span class="sd">         rst = tcp.flags.rst,            # reset connection flag</span>
<span class="sd">         len = tcp.raw_len,              # payload length, header excludes</span>
<span class="sd">         first = tcp.seq,                # this sequence number</span>
<span class="sd">         last = tcp.seq + tcp.raw_len,   # next (wanted) sequence number</span>
<span class="sd">         payload = tcp.raw,              # raw bytearray type payload</span>
<span class="sd">       )</span>

<span class="sd">tcp.datagram</span>
<span class="sd">    Data structure for **reassembled TCP datagram** (element from</span>
<span class="sd">    :attr:`~pcapkit.reassembly.reassembly.Reassembly.datagram` *tuple*)</span>
<span class="sd">    is as following:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       (tuple) datagram</span>
<span class="sd">        |--&gt; (Info) data</span>
<span class="sd">        |     |--&gt; &#39;NotImplemented&#39; : (bool) True --&gt; implemented</span>
<span class="sd">        |     |--&gt; &#39;id&#39; : (Info) original packet identifier</span>
<span class="sd">        |     |            |--&gt; &#39;src&#39; --&gt; (tuple)</span>
<span class="sd">        |     |            |               |--&gt; (str) ip.src</span>
<span class="sd">        |     |            |               |--&gt; (int) tcp.srcport</span>
<span class="sd">        |     |            |--&gt; &#39;dst&#39; --&gt; (tuple)</span>
<span class="sd">        |     |            |               |--&gt; (str) ip.dst</span>
<span class="sd">        |     |            |               |--&gt; (int) tcp.dstport</span>
<span class="sd">        |     |            |--&gt; &#39;ack&#39; --&gt; (int) original packet ACK number</span>
<span class="sd">        |     |--&gt; &#39;index&#39; : (tuple) packet numbers</span>
<span class="sd">        |     |               |--&gt; (int) original packet range number</span>
<span class="sd">        |     |--&gt; &#39;payload&#39; : (Optional[bytes]) reassembled application layer data</span>
<span class="sd">        |     |--&gt; &#39;packets&#39; : (Tuple[Analysis]) analysed payload</span>
<span class="sd">        |--&gt; (Info) data</span>
<span class="sd">        |     |--&gt; &#39;NotImplemented&#39; : (bool) False --&gt; not implemented</span>
<span class="sd">        |     |--&gt; &#39;id&#39; : (Info) original packet identifier</span>
<span class="sd">        |     |            |--&gt; &#39;src&#39; --&gt; (tuple)</span>
<span class="sd">        |     |            |               |--&gt; (str) ip.src</span>
<span class="sd">        |     |            |               |--&gt; (int) tcp.srcport</span>
<span class="sd">        |     |            |--&gt; &#39;dst&#39; --&gt; (tuple)</span>
<span class="sd">        |     |            |               |--&gt; (str) ip.dst</span>
<span class="sd">        |     |            |               |--&gt; (int) tcp.dstport</span>
<span class="sd">        |     |            |--&gt; &#39;ack&#39; --&gt; (int) original packet ACK number</span>
<span class="sd">        |     |--&gt; &#39;ack&#39; : (int) original packet ACK number</span>
<span class="sd">        |     |--&gt; &#39;index&#39; : (tuple) packet numbers</span>
<span class="sd">        |     |               |--&gt; (int) original packet range number</span>
<span class="sd">        |     |--&gt; &#39;payload&#39; : (Optional[tuple]) partially reassembled payload</span>
<span class="sd">        |     |                 |--&gt; (Optional[bytes]) payload fragment</span>
<span class="sd">        |     |--&gt; &#39;packets&#39; : (Tuple[Analysis]) analysed payloads</span>
<span class="sd">        |--&gt; (Info) data ...</span>

<span class="sd">tcp.buffer</span>
<span class="sd">    Data structure for internal buffering when performing reassembly algorithms</span>
<span class="sd">    (:attr:`~pcapkit.reassembly.reassembly.Reassembly._buffer`) is as following:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       (dict) buffer --&gt; memory buffer for reassembly</span>
<span class="sd">        |--&gt; (tuple) BUFID : (dict)</span>
<span class="sd">        |       |--&gt; ip.src      |</span>
<span class="sd">        |       |--&gt; ip.dst      |</span>
<span class="sd">        |       |--&gt; tcp.srcport |</span>
<span class="sd">        |       |--&gt; tcp.dstport |</span>
<span class="sd">        |                        |--&gt; &#39;hdl&#39; : (list) hole descriptor list</span>
<span class="sd">        |                        |             |--&gt; (Info) hole --&gt; hole descriptor</span>
<span class="sd">        |                        |                   |--&gt; &quot;first&quot; --&gt; (int) start of hole</span>
<span class="sd">        |                        |                   |--&gt; &quot;last&quot; --&gt; (int) stop of hole</span>
<span class="sd">        |                        |--&gt; (int) ACK : (dict)</span>
<span class="sd">        |                        |                 |--&gt; &#39;ind&#39; : (list) list of reassembled packets</span>
<span class="sd">        |                        |                 |             |--&gt; (int) packet range number</span>
<span class="sd">        |                        |                 |--&gt; &#39;isn&#39; : (int) ISN of payload buffer</span>
<span class="sd">        |                        |                 |--&gt; &#39;len&#39; : (int) length of payload buffer</span>
<span class="sd">        |                        |                 |--&gt; &#39;raw&#39; : (bytearray) reassembled payload, holes set to b&#39;\\x00&#39;</span>
<span class="sd">        |                        |--&gt; (int) ACK ...</span>
<span class="sd">        |                        |--&gt; ...</span>
<span class="sd">        |--&gt; (tuple) BUFID ...</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">from</span> <span class="nn">pcapkit.corekit.infoclass</span> <span class="kn">import</span> <span class="n">Info</span>
<span class="kn">from</span> <span class="nn">pcapkit.foundation.analysis</span> <span class="kn">import</span> <span class="n">analyse</span>
<span class="kn">from</span> <span class="nn">pcapkit.reassembly.reassembly</span> <span class="kn">import</span> <span class="n">Reassembly</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;TCP_Reassembly&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="TCP_Reassembly"><a class="viewcode-back" href="../../../reassembly/tcp.html#pcapkit.reassembly.tcp.TCP_Reassembly">[docs]</a><span class="k">class</span> <span class="nc">TCP_Reassembly</span><span class="p">(</span><span class="n">Reassembly</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reassembly for TCP payload.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; from pcapkit.reassembly import TCP_Reassembly</span>
<span class="sd">        # Initialise instance:</span>
<span class="sd">        &gt;&gt;&gt; tcp_reassembly = TCP_Reassembly()</span>
<span class="sd">        # Call reassembly:</span>
<span class="sd">        &gt;&gt;&gt; tcp_reassembly(packet_dict)</span>
<span class="sd">        # Fetch result:</span>
<span class="sd">        &gt;&gt;&gt; result = tcp_reassembly.datagram</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">##########################################################################</span>
    <span class="c1"># Methods.</span>
    <span class="c1">##########################################################################</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Protocol of current packet.</span>

<span class="sd">        :rtype: Literal[&#39;Transmission Control Protocol&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;Transmission Control Protocol&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">protocol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Protocol of current reassembly object.</span>

<span class="sd">        :rtype: Literal[&#39;TCP&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;TCP&#39;</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Methods.</span>
    <span class="c1">##########################################################################</span>

<div class="viewcode-block" id="TCP_Reassembly.reassembly"><a class="viewcode-back" href="../../../reassembly/tcp.html#pcapkit.reassembly.tcp.TCP_Reassembly.reassembly">[docs]</a>    <span class="k">def</span> <span class="nf">reassembly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reassembly procedure.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            info (pcapkit.corekit.infoclass.Info): :term:`info &lt;tcp.packet&gt;` dict of packets to be reassembled</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">BUFID</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">bufid</span>  <span class="c1"># Buffer Identifier</span>
        <span class="n">DSN</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">dsn</span>      <span class="c1"># Data Sequence Number</span>
        <span class="n">ACK</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">ack</span>      <span class="c1"># Acknowledgement Number</span>
        <span class="n">FIN</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">fin</span>      <span class="c1"># Finish Flag (Termination)</span>
        <span class="n">RST</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">rst</span>      <span class="c1"># Reset Connection Flag (Termination)</span>
        <span class="n">SYN</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">syn</span>      <span class="c1"># Synchronise Flag (Establishment)</span>

        <span class="c1"># when SYN is set, reset buffer of this session</span>
        <span class="k">if</span> <span class="n">SYN</span> <span class="ow">and</span> <span class="n">BUFID</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dtgram</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">],</span> <span class="n">bufid</span><span class="o">=</span><span class="n">BUFID</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">]</span>

        <span class="c1"># initialise buffer with BUFID &amp; ACK</span>
        <span class="k">if</span> <span class="n">BUFID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;hdl&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">Info</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="n">info</span><span class="o">.</span><span class="n">len</span><span class="p">,</span> <span class="n">last</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">)],</span>
                <span class="n">ACK</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">ind</span><span class="o">=</span><span class="p">[</span><span class="n">info</span><span class="o">.</span><span class="n">num</span><span class="p">],</span>
                    <span class="n">isn</span><span class="o">=</span><span class="n">info</span><span class="o">.</span><span class="n">dsn</span><span class="p">,</span>
                    <span class="nb">len</span><span class="o">=</span><span class="n">info</span><span class="o">.</span><span class="n">len</span><span class="p">,</span>
                    <span class="n">raw</span><span class="o">=</span><span class="n">info</span><span class="o">.</span><span class="n">payload</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># initialise buffer with ACK</span>
            <span class="k">if</span> <span class="n">ACK</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">][</span><span class="n">ACK</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">ind</span><span class="o">=</span><span class="p">[</span><span class="n">info</span><span class="o">.</span><span class="n">num</span><span class="p">],</span>
                    <span class="n">isn</span><span class="o">=</span><span class="n">info</span><span class="o">.</span><span class="n">dsn</span><span class="p">,</span>
                    <span class="nb">len</span><span class="o">=</span><span class="n">info</span><span class="o">.</span><span class="n">len</span><span class="p">,</span>
                    <span class="n">raw</span><span class="o">=</span><span class="n">info</span><span class="o">.</span><span class="n">payload</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># append packet index</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">][</span><span class="n">ACK</span><span class="p">][</span><span class="s1">&#39;ind&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">num</span><span class="p">)</span>

                <span class="c1"># record fragment payload</span>
                <span class="n">ISN</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">][</span><span class="n">ACK</span><span class="p">][</span><span class="s1">&#39;isn&#39;</span><span class="p">]</span>   <span class="c1"># Initial Sequence Number</span>
                <span class="n">RAW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">][</span><span class="n">ACK</span><span class="p">][</span><span class="s1">&#39;raw&#39;</span><span class="p">]</span>   <span class="c1"># Raw Payload Data</span>
                <span class="k">if</span> <span class="n">DSN</span> <span class="o">&gt;=</span> <span class="n">ISN</span><span class="p">:</span>  <span class="c1"># if fragment goes after existing payload</span>
                    <span class="n">LEN</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">][</span><span class="n">ACK</span><span class="p">][</span><span class="s1">&#39;len&#39;</span><span class="p">]</span>
                    <span class="n">GAP</span> <span class="o">=</span> <span class="n">DSN</span> <span class="o">-</span> <span class="p">(</span><span class="n">ISN</span> <span class="o">+</span> <span class="n">LEN</span><span class="p">)</span>     <span class="c1"># gap length between payloads</span>
                    <span class="k">if</span> <span class="n">GAP</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>    <span class="c1"># if fragment goes after existing payload</span>
                        <span class="n">RAW</span> <span class="o">+=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">GAP</span><span class="p">)</span> <span class="o">+</span> <span class="n">info</span><span class="o">.</span><span class="n">payload</span>
                    <span class="k">else</span><span class="p">:</span>           <span class="c1"># if fragment partially overlaps existing payload</span>
                        <span class="n">RAW</span><span class="p">[</span><span class="n">DSN</span><span class="o">-</span><span class="n">ISN</span><span class="p">:]</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">payload</span>
                <span class="k">else</span><span class="p">:</span>           <span class="c1"># if fragment exceeds existing payload</span>
                    <span class="n">LEN</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">len</span>
                    <span class="n">GAP</span> <span class="o">=</span> <span class="n">ISN</span> <span class="o">-</span> <span class="p">(</span><span class="n">DSN</span> <span class="o">+</span> <span class="n">LEN</span><span class="p">)</span>     <span class="c1"># gap length between payloads</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">][</span><span class="n">ACK</span><span class="p">][</span><span class="s1">&#39;isn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DSN</span>
                    <span class="k">if</span> <span class="n">GAP</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>    <span class="c1"># if fragment exceeds existing payload</span>
                        <span class="n">RAW</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">payload</span> <span class="o">+</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">GAP</span><span class="p">)</span> <span class="o">+</span> <span class="n">RAW</span>
                    <span class="k">else</span><span class="p">:</span>           <span class="c1"># if fragment partially overlaps existing payload</span>
                        <span class="n">RAW</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">payload</span> <span class="o">+</span> <span class="n">RAW</span><span class="p">[</span><span class="n">ISN</span><span class="o">-</span><span class="n">GAP</span><span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">][</span><span class="n">ACK</span><span class="p">][</span><span class="s1">&#39;raw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RAW</span>       <span class="c1"># update payload datagram</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">][</span><span class="n">ACK</span><span class="p">][</span><span class="s1">&#39;len&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">RAW</span><span class="p">)</span>  <span class="c1"># update payload length</span>

            <span class="c1"># update hole descriptor list</span>
            <span class="n">HDL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">][</span><span class="s1">&#39;hdl&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">hole</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">HDL</span><span class="p">):</span>                            <span class="c1"># step one</span>
                <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">first</span> <span class="o">&gt;</span> <span class="n">hole</span><span class="o">.</span><span class="n">last</span><span class="p">:</span>                                  <span class="c1"># step two</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">last</span> <span class="o">&lt;</span> <span class="n">hole</span><span class="o">.</span><span class="n">first</span><span class="p">:</span>                                  <span class="c1"># step three</span>
                    <span class="k">continue</span>
                <span class="k">del</span> <span class="n">HDL</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>                                              <span class="c1"># step four</span>
                <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">first</span> <span class="o">&gt;</span> <span class="n">hole</span><span class="o">.</span><span class="n">first</span><span class="p">:</span>                                 <span class="c1"># step five</span>
                    <span class="n">new_hole</span> <span class="o">=</span> <span class="n">Info</span><span class="p">(</span>
                        <span class="n">first</span><span class="o">=</span><span class="n">hole</span><span class="o">.</span><span class="n">first</span><span class="p">,</span>
                        <span class="n">last</span><span class="o">=</span><span class="n">info</span><span class="o">.</span><span class="n">first</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">HDL</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">new_hole</span><span class="p">)</span>
                    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">last</span> <span class="o">&lt;</span> <span class="n">hole</span><span class="o">.</span><span class="n">last</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">FIN</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">RST</span><span class="p">:</span>           <span class="c1"># step six</span>
                    <span class="n">new_hole</span> <span class="o">=</span> <span class="n">Info</span><span class="p">(</span>
                        <span class="n">first</span><span class="o">=</span><span class="n">info</span><span class="o">.</span><span class="n">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">last</span><span class="o">=</span><span class="n">hole</span><span class="o">.</span><span class="n">last</span>
                    <span class="p">)</span>
                    <span class="n">HDL</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">new_hole</span><span class="p">)</span>
                <span class="k">break</span>                                                       <span class="c1"># step seven</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">][</span><span class="s1">&#39;hdl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HDL</span>                                <span class="c1"># update HDL</span>

        <span class="c1"># when FIN/RST is set, submit buffer of this session</span>
        <span class="k">if</span> <span class="n">FIN</span> <span class="ow">or</span> <span class="n">RST</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dtgram</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">],</span> <span class="n">bufid</span><span class="o">=</span><span class="n">BUFID</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">BUFID</span><span class="p">]</span></div>

<div class="viewcode-block" id="TCP_Reassembly.submit"><a class="viewcode-back" href="../../../reassembly/tcp.html#pcapkit.reassembly.tcp.TCP_Reassembly.submit">[docs]</a>    <span class="k">def</span> <span class="nf">submit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">bufid</span><span class="p">):</span>  <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="sd">&quot;&quot;&quot;Submit reassembled payload.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            buf (dict): :term:`buffer &lt;tcp.buffer&gt;` dict of reassembled packets</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bufid (tuple): buffer identifier</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[dict]: reassembled :term:`packets &lt;tcp.datagram&gt;`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">datagram</span> <span class="o">=</span> <span class="p">[]</span>           <span class="c1"># reassembled datagram</span>
        <span class="n">HDL</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;hdl&#39;</span><span class="p">)</span>    <span class="c1"># hole descriptor list (remove from dict)</span>

        <span class="c1"># check through every buffer with ACK</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span> <span class="ow">in</span> <span class="n">buf</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># if this buffer is not implemented</span>
            <span class="c1"># go through every hole and extract received payload</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">HDL</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strflg</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">HDL</span><span class="p">:</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="n">hole</span><span class="o">.</span><span class="n">first</span>
                    <span class="n">byte</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">hole</span><span class="o">.</span><span class="n">last</span>
                    <span class="k">if</span> <span class="n">byte</span><span class="p">:</span>    <span class="c1"># strip empty payload</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">byte</span><span class="p">)</span>
                <span class="n">byte</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">][</span><span class="n">start</span><span class="p">:]</span>
                <span class="k">if</span> <span class="n">byte</span><span class="p">:</span>    <span class="c1"># strip empty payload</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">byte</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">:</span>    <span class="c1"># strip empty buffer</span>
                    <span class="n">packet</span> <span class="o">=</span> <span class="n">Info</span><span class="p">(</span>
                        <span class="bp">NotImplemented</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">Info</span><span class="p">(</span>
                            <span class="n">src</span><span class="o">=</span><span class="p">(</span><span class="n">bufid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bufid</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                            <span class="n">dst</span><span class="o">=</span><span class="p">(</span><span class="n">bufid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bufid</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                            <span class="n">ack</span><span class="o">=</span><span class="n">ack</span><span class="p">,</span>
                        <span class="p">),</span>
                        <span class="n">index</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="s1">&#39;ind&#39;</span><span class="p">]),</span>
                        <span class="n">payload</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">packets</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">analyse</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">frag</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">frag</span><span class="p">))</span> <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">data</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">datagram</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
            <span class="c1"># if this buffer is implemented</span>
            <span class="c1"># export payload data &amp; convert into bytes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">:</span>    <span class="c1"># strip empty buffer</span>
                    <span class="n">packet</span> <span class="o">=</span> <span class="n">Info</span><span class="p">(</span>
                        <span class="bp">NotImplemented</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">Info</span><span class="p">(</span>
                            <span class="n">src</span><span class="o">=</span><span class="p">(</span><span class="n">bufid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bufid</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                            <span class="n">dst</span><span class="o">=</span><span class="p">(</span><span class="n">bufid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bufid</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                            <span class="n">ack</span><span class="o">=</span><span class="n">ack</span><span class="p">,</span>
                        <span class="p">),</span>
                        <span class="n">index</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="s1">&#39;ind&#39;</span><span class="p">]),</span>
                        <span class="n">payload</span><span class="o">=</span><span class="nb">bytes</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">packets</span><span class="o">=</span><span class="p">(</span><span class="n">analyse</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)),),</span>
                    <span class="p">)</span>
                    <span class="n">datagram</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">datagram</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">PyPCAPKit</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=JarryShaw&repo=pypcapkit&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pcapkit.html">Stream PCAP File Extractor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cli.html">Command Line Interface</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018-2020, Jarry Shaw.
      
    </div>

    
    <a href="https://github.com/JarryShaw/pypcapkit" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>